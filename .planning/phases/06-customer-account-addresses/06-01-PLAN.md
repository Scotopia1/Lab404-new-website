# Plan 06-01: Customer Address Management

**Phase:** 6 - Customer Account - Address Management
**Plan:** 06-01
**Objective:** Enable customers to manage shipping and billing addresses with full CRUD operations

---

## Context

**Current State:**
- Address database schema exists (`addresses` table in packages/database/src/schema/customers.ts)
- API endpoints are fully implemented at `/api/customers/me/addresses`:
  - GET `/api/customers/me/addresses` - List addresses (line 223 in customers.routes.ts)
  - POST `/api/customers/me/addresses` - Create address (line 247)
  - PUT `/api/customers/me/addresses/:id` - Update address (line 294)
  - DELETE `/api/customers/me/addresses/:id` - Delete address (line 358)
- Address validation schema exists (addressSchema, lines 21-58 in customers.routes.ts)
- UI page exists but uses mock data (apps/lab404-website/src/app/account/addresses/page.tsx)
- Default address logic is implemented in API (isDefault field, auto-unsets other defaults of same type)
- Checkout page exists and currently requires manual address entry

**Address Schema Fields:**
```typescript
{
  id: uuid
  customerId: uuid (references customers)
  type: 'shipping' | 'billing'
  firstName: string (required, max 100)
  lastName: string (required, max 100)
  company?: string (optional, max 255)
  addressLine1: string (required, max 255)
  addressLine2?: string (optional, max 255)
  city: string (required, max 100)
  state?: string (optional, max 100)
  postalCode?: string (optional, max 20)
  country: string (required, max 100)
  phone?: string (optional, max 50, validated regex)
  isDefault: boolean (default false)
  createdAt: timestamp
  updatedAt: timestamp
}
```

**Dependencies:**
- React Query (@tanstack/react-query) - already installed
- shadcn/ui components (Dialog, Form, Input) - already installed
- Existing auth and API infrastructure

**Target:**
- Functional address management with list, add, edit, delete operations
- Default address toggle (per type: shipping/billing)
- Form validation matching API schema
- Checkout integration to use saved addresses
- Type-safe TypeScript throughout

---

## Execution Context

**Files to Read:**
@apps/lab404-website/src/app/account/addresses/page.tsx (existing UI page with mock data)
@apps/api/src/routes/customers.routes.ts (API endpoints and validation schema, lines 21-58 and 223-389)
@packages/database/src/schema/customers.ts (addresses table schema, lines 56-73)
@apps/lab404-website/src/app/checkout/page.tsx (existing checkout form to integrate with)
@apps/lab404-website/src/hooks/use-orders.ts (reference pattern for React Query hooks)

**Tools Available:**
- React 19 with Next.js 16
- React Query for data fetching
- shadcn/ui components (Dialog, Form, Input, Button, Card, Badge, Label)
- React Hook Form for form state management
- Zod for validation (matching API schema)
- Lucide React icons

**Code Patterns:**
- Follow existing React Query hook patterns (see use-orders.ts)
- Use shadcn/ui Dialog for add/edit forms
- Use AlertDialog for delete confirmation
- Follow existing API client patterns (apps/lab404-website/src/lib/api.ts)
- Type-safe responses with TypeScript interfaces

---

## Tasks

### Task 1: Create React Query hooks for address operations
**File:** `apps/lab404-website/src/hooks/use-addresses.ts` (NEW)

**What to do:**
Create comprehensive React Query hooks for address CRUD operations:
- `useAddresses()` - Fetch all customer addresses
- `useAddress(id: string)` - Fetch single address (if needed for future use)
- `useCreateAddress()` - Mutation for creating address
- `useUpdateAddress()` - Mutation for updating address
- `useDeleteAddress()` - Mutation for deleting address

**Implementation details:**
```typescript
// Response types matching API
interface Address {
  id: string;
  customerId: string;
  type: 'shipping' | 'billing';
  firstName: string;
  lastName: string;
  company?: string | null;
  addressLine1: string;
  addressLine2?: string | null;
  city: string;
  state?: string | null;
  postalCode?: string | null;
  country: string;
  phone?: string | null;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
}

// Create/Update payload (without id, customerId, timestamps)
interface AddressInput {
  type: 'shipping' | 'billing';
  firstName: string;
  lastName: string;
  company?: string;
  addressLine1: string;
  addressLine2?: string;
  city: string;
  state?: string;
  postalCode?: string;
  country: string;
  phone?: string;
  isDefault?: boolean;
}

// useAddresses hook
export function useAddresses(): UseQueryResult<Address[]> {
  return useQuery({
    queryKey: ['addresses'],
    queryFn: async () => {
      const response = await api.get<Address[]>('/customers/me/addresses');
      return response.data;
    },
  });
}

// useCreateAddress hook
export function useCreateAddress() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (data: AddressInput) => {
      const response = await api.post<Address>('/customers/me/addresses', data);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['addresses'] });
    },
  });
}

// useUpdateAddress hook
export function useUpdateAddress() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async ({ id, data }: { id: string; data: Partial<AddressInput> }) => {
      const response = await api.put<Address>(`/customers/me/addresses/${id}`, data);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['addresses'] });
    },
  });
}

// useDeleteAddress hook
export function useDeleteAddress() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: async (id: string) => {
      await api.delete(`/customers/me/addresses/${id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['addresses'] });
    },
  });
}
```

**Success criteria:**
- All hooks return proper types
- Mutations invalidate queries on success
- Error handling included
- Follows existing patterns from use-orders.ts

---

### Task 2: Create address form component
**File:** `apps/lab404-website/src/components/addresses/address-form.tsx` (NEW)

**What to do:**
Create a reusable address form component for both add and edit operations.

**Implementation details:**
```typescript
interface AddressFormProps {
  address?: Address; // undefined for create, defined for edit
  onSubmit: (data: AddressInput) => void;
  isSubmitting: boolean;
}

export function AddressForm({ address, onSubmit, isSubmitting }: AddressFormProps) {
  // Use React Hook Form with Zod validation
  const form = useForm<AddressInput>({
    resolver: zodResolver(addressFormSchema),
    defaultValues: address ? {
      type: address.type,
      firstName: address.firstName,
      lastName: address.lastName,
      company: address.company || '',
      addressLine1: address.addressLine1,
      addressLine2: address.addressLine2 || '',
      city: address.city,
      state: address.state || '',
      postalCode: address.postalCode || '',
      country: address.country,
      phone: address.phone || '',
      isDefault: address.isDefault,
    } : {
      type: 'shipping',
      firstName: '',
      lastName: '',
      company: '',
      addressLine1: '',
      addressLine2: '',
      city: '',
      state: '',
      postalCode: '',
      country: '',
      phone: '',
      isDefault: false,
    }
  });

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        {/* Type selector (shipping/billing) */}
        <FormField name="type" ... />

        {/* Name fields (firstName, lastName) in grid */}
        <div className="grid grid-cols-2 gap-4">
          <FormField name="firstName" ... />
          <FormField name="lastName" ... />
        </div>

        {/* Company (optional) */}
        <FormField name="company" ... />

        {/* Address fields */}
        <FormField name="addressLine1" label="Address Line 1" ... />
        <FormField name="addressLine2" label="Address Line 2" ... />

        {/* City, State, Postal Code in grid */}
        <div className="grid grid-cols-3 gap-4">
          <FormField name="city" ... />
          <FormField name="state" ... />
          <FormField name="postalCode" ... />
        </div>

        {/* Country */}
        <FormField name="country" ... />

        {/* Phone (optional) */}
        <FormField name="phone" ... />

        {/* Is Default checkbox */}
        <FormField
          name="isDefault"
          render={({ field }) => (
            <FormItem className="flex items-center space-x-2">
              <FormControl>
                <Checkbox
                  checked={field.value}
                  onCheckedChange={field.onChange}
                />
              </FormControl>
              <FormLabel>Set as default {form.watch('type')} address</FormLabel>
            </FormItem>
          )}
        />

        {/* Submit button */}
        <Button type="submit" disabled={isSubmitting}>
          {isSubmitting ? 'Saving...' : address ? 'Update Address' : 'Add Address'}
        </Button>
      </form>
    </Form>
  );
}
```

**Zod validation schema:**
Match the API addressSchema exactly (from customers.routes.ts lines 21-58):
```typescript
const addressFormSchema = z.object({
  type: z.enum(['shipping', 'billing']),
  isDefault: z.boolean().optional().default(false),
  firstName: z.string().min(1, 'First name is required').max(100),
  lastName: z.string().min(1, 'Last name is required').max(100),
  company: z.string().max(255).optional(),
  addressLine1: z.string().min(1, 'Address is required').max(255),
  addressLine2: z.string().max(255).optional(),
  city: z.string().min(1, 'City is required').max(100),
  state: z.string().max(100).optional(),
  postalCode: z.string().max(20).optional(),
  country: z.string().min(1, 'Country is required').max(100),
  phone: z.string().max(50).regex(/^[+]?[\d\s\-().]*$/, 'Please enter a valid phone number').optional().or(z.literal('')),
});
```

**Success criteria:**
- Form renders all required fields
- Validation matches API schema exactly
- Default values populate correctly for edit mode
- Form is accessible and responsive
- Error messages display properly

---

### Task 3: Update address list page with live data and dialogs
**File:** `apps/lab404-website/src/app/account/addresses/page.tsx` (EDIT)

**What to do:**
Replace mock data with React Query hooks and add add/edit/delete functionality.

**Changes:**
1. Replace mock data with `useAddresses()` hook
2. Add "Add Address" dialog with AddressForm
3. Add "Edit Address" dialog for each address card
4. Add delete confirmation AlertDialog
5. Handle loading, error, and empty states
6. Display address type badge (Shipping/Billing)
7. Show "Default" badge for default addresses
8. Handle mutations with toast notifications (success/error)

**Implementation structure:**
```typescript
'use client';

import { useState } from 'react';
import { useAddresses, useCreateAddress, useUpdateAddress, useDeleteAddress } from '@/hooks/use-addresses';
import { AddressForm } from '@/components/addresses/address-form';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { AlertDialog, AlertDialogAction, AlertDialogCancel, AlertDialogContent, AlertDialogDescription, AlertDialogFooter, AlertDialogHeader, AlertDialogTitle } from '@/components/ui/alert-dialog';
import { useToast } from '@/hooks/use-toast';
// ... other imports

export default function AddressesPage() {
  const { data: addresses, isLoading, error } = useAddresses();
  const createAddress = useCreateAddress();
  const updateAddress = useUpdateAddress();
  const deleteAddress = useDeleteAddress();
  const { toast } = useToast();

  const [isAddDialogOpen, setIsAddDialogOpen] = useState(false);
  const [editingAddress, setEditingAddress] = useState<Address | null>(null);
  const [deletingAddressId, setDeletingAddressId] = useState<string | null>(null);

  const handleCreate = async (data: AddressInput) => {
    try {
      await createAddress.mutateAsync(data);
      toast({ title: 'Address added successfully' });
      setIsAddDialogOpen(false);
    } catch (error) {
      toast({ title: 'Failed to add address', variant: 'destructive' });
    }
  };

  const handleUpdate = async (data: AddressInput) => {
    if (!editingAddress) return;
    try {
      await updateAddress.mutateAsync({ id: editingAddress.id, data });
      toast({ title: 'Address updated successfully' });
      setEditingAddress(null);
    } catch (error) {
      toast({ title: 'Failed to update address', variant: 'destructive' });
    }
  };

  const handleDelete = async () => {
    if (!deletingAddressId) return;
    try {
      await deleteAddress.mutateAsync(deletingAddressId);
      toast({ title: 'Address deleted successfully' });
      setDeletingAddressId(null);
    } catch (error) {
      toast({ title: 'Failed to delete address', variant: 'destructive' });
    }
  };

  // Render loading state
  if (isLoading) {
    return <div>Loading addresses...</div>;
  }

  // Render error state
  if (error) {
    return <div>Error loading addresses</div>;
  }

  // Render empty state
  if (!addresses || addresses.length === 0) {
    return <div>No addresses yet. Add your first address!</div>;
  }

  // Render address list with cards
  return (
    <AccountLayout>
      {/* Header with "Add Address" button */}
      <Dialog open={isAddDialogOpen} onOpenChange={setIsAddDialogOpen}>
        <DialogTrigger asChild>
          <Button>
            <Plus className="mr-2 h-4 w-4" />
            Add Address
          </Button>
        </DialogTrigger>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Add New Address</DialogTitle>
          </DialogHeader>
          <AddressForm
            onSubmit={handleCreate}
            isSubmitting={createAddress.isPending}
          />
        </DialogContent>
      </Dialog>

      {/* Address cards grid */}
      <div className="grid gap-6 md:grid-cols-2">
        {addresses.map((address) => (
          <Card key={address.id}>
            <CardHeader>
              {/* Type badge (Shipping/Billing) */}
              <Badge>{address.type}</Badge>
              {/* Default badge if isDefault */}
              {address.isDefault && <Badge variant="secondary">Default</Badge>}

              {/* Edit and Delete buttons */}
              <Button onClick={() => setEditingAddress(address)}>
                <Edit2 className="h-4 w-4" />
              </Button>
              <Button onClick={() => setDeletingAddressId(address.id)}>
                <Trash2 className="h-4 w-4" />
              </Button>
            </CardHeader>
            <CardContent>
              {/* Display address details */}
              <p>{address.firstName} {address.lastName}</p>
              {address.company && <p>{address.company}</p>}
              <p>{address.addressLine1}</p>
              {address.addressLine2 && <p>{address.addressLine2}</p>}
              <p>{address.city}, {address.state} {address.postalCode}</p>
              <p>{address.country}</p>
              {address.phone && <p>{address.phone}</p>}
            </CardContent>
          </Card>
        ))}
      </div>

      {/* Edit Dialog */}
      <Dialog open={!!editingAddress} onOpenChange={(open) => !open && setEditingAddress(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Edit Address</DialogTitle>
          </DialogHeader>
          {editingAddress && (
            <AddressForm
              address={editingAddress}
              onSubmit={handleUpdate}
              isSubmitting={updateAddress.isPending}
            />
          )}
        </DialogContent>
      </Dialog>

      {/* Delete Confirmation Dialog */}
      <AlertDialog open={!!deletingAddressId} onOpenChange={(open) => !open && setDeletingAddressId(null)}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Address</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete this address? This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction onClick={handleDelete} disabled={deleteAddress.isPending}>
              {deleteAddress.isPending ? 'Deleting...' : 'Delete'}
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </AccountLayout>
  );
}
```

**Success criteria:**
- Address list displays live data from API
- Add/Edit/Delete operations work correctly
- Loading, error, and empty states handled
- Toast notifications for all operations
- Dialogs open/close properly
- Type and default badges display correctly
- Responsive layout (2 columns on desktop)

---

### Task 4: Integrate saved addresses into checkout flow
**File:** `apps/lab404-website/src/app/checkout/page.tsx` (EDIT)

**What to do:**
Add option to select from saved addresses during checkout, falling back to manual entry.

**Changes:**
1. Import `useAddresses()` hook
2. Add address selector component before/above manual address form
3. When address is selected, populate form fields
4. Show "Use a different address" button to switch back to manual entry
5. Filter addresses by type (shipping addresses only for shipping info)
6. Highlight default shipping address
7. Allow user to save new address to account (optional checkbox)

**Implementation approach:**
```typescript
'use client';

import { useState } from 'react';
import { useAddresses } from '@/hooks/use-addresses';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
// ... other imports

export default function CheckoutPage() {
  const { data: addresses } = useAddresses();
  const [selectedAddressId, setSelectedAddressId] = useState<string | null>(null);
  const [useManualEntry, setUseManualEntry] = useState(false);
  const [saveToAccount, setSaveToAccount] = useState(false);

  // Filter shipping addresses and get default
  const shippingAddresses = addresses?.filter(a => a.type === 'shipping') || [];
  const defaultShippingAddress = shippingAddresses.find(a => a.isDefault);

  // Auto-select default address on mount (if exists and not using manual entry)
  useEffect(() => {
    if (defaultShippingAddress && !selectedAddressId && !useManualEntry) {
      setSelectedAddressId(defaultShippingAddress.id);
    }
  }, [defaultShippingAddress]);

  // Get selected address
  const selectedAddress = shippingAddresses.find(a => a.id === selectedAddressId);

  // Populate form when address selected
  useEffect(() => {
    if (selectedAddress && !useManualEntry) {
      form.setValue('firstName', selectedAddress.firstName);
      form.setValue('lastName', selectedAddress.lastName);
      // ... set all other fields
    }
  }, [selectedAddress, useManualEntry]);

  return (
    <div>
      {/* Saved Addresses Section (if addresses exist and not using manual entry) */}
      {shippingAddresses.length > 0 && !useManualEntry && (
        <div className="space-y-4">
          <h3>Saved Addresses</h3>
          <RadioGroup value={selectedAddressId || ''} onValueChange={setSelectedAddressId}>
            {shippingAddresses.map((address) => (
              <div key={address.id} className="flex items-start space-x-2 border p-4 rounded">
                <RadioGroupItem value={address.id} id={address.id} />
                <label htmlFor={address.id} className="flex-1 cursor-pointer">
                  <div className="font-medium">
                    {address.firstName} {address.lastName}
                    {address.isDefault && <Badge className="ml-2">Default</Badge>}
                  </div>
                  <div className="text-sm text-muted-foreground">
                    {address.addressLine1}, {address.city}, {address.state} {address.postalCode}
                  </div>
                </label>
              </div>
            ))}
          </RadioGroup>
          <Button variant="outline" onClick={() => setUseManualEntry(true)}>
            Use a different address
          </Button>
        </div>
      )}

      {/* Manual Address Entry (if using manual entry or no saved addresses) */}
      {(useManualEntry || shippingAddresses.length === 0) && (
        <div className="space-y-4">
          {shippingAddresses.length > 0 && (
            <Button variant="outline" onClick={() => setUseManualEntry(false)}>
              Choose from saved addresses
            </Button>
          )}

          {/* Existing address form fields */}
          <FormField name="firstName" ... />
          {/* ... all other address fields */}

          {/* Optional: Save to account checkbox (for logged-in users) */}
          <FormField
            name="saveToAccount"
            render={({ field }) => (
              <FormItem className="flex items-center space-x-2">
                <FormControl>
                  <Checkbox
                    checked={saveToAccount}
                    onCheckedChange={setSaveToAccount}
                  />
                </FormControl>
                <FormLabel>Save this address to my account</FormLabel>
              </FormItem>
            )}
          />
        </div>
      )}

      {/* Rest of checkout form (payment method, etc.) */}
    </div>
  );
}
```

**Success criteria:**
- Saved addresses display in checkout
- Default address auto-selected
- Address selection populates form fields
- Can switch between saved and manual entry
- Optional "save to account" checkbox works
- Checkout flow remains functional

---

### Task 5: Add TypeScript types file for addresses
**File:** `apps/lab404-website/src/types/address.ts` (NEW)

**What to do:**
Create a centralized TypeScript types file for address-related types, ensuring consistency across components.

**Implementation:**
```typescript
// Address entity from API
export interface Address {
  id: string;
  customerId: string;
  type: 'shipping' | 'billing';
  firstName: string;
  lastName: string;
  company?: string | null;
  addressLine1: string;
  addressLine2?: string | null;
  city: string;
  state?: string | null;
  postalCode?: string | null;
  country: string;
  phone?: string | null;
  isDefault: boolean;
  createdAt: string;
  updatedAt: string;
}

// Address input for create/update operations
export interface AddressInput {
  type: 'shipping' | 'billing';
  firstName: string;
  lastName: string;
  company?: string;
  addressLine1: string;
  addressLine2?: string;
  city: string;
  state?: string;
  postalCode?: string;
  country: string;
  phone?: string;
  isDefault?: boolean;
}

// Address form props
export interface AddressFormProps {
  address?: Address;
  onSubmit: (data: AddressInput) => void;
  isSubmitting: boolean;
}

// Address display (formatted for UI)
export interface AddressDisplay {
  id: string;
  type: 'shipping' | 'billing';
  fullName: string;
  fullAddress: string;
  isDefault: boolean;
}
```

**Success criteria:**
- Types exported and reusable
- All components import from this file
- Types match API schema exactly

---

### Task 6: Test address management flow and create documentation
**File:** `.planning/phases/06-customer-account-addresses/06-01-TESTING.md` (NEW)

**What to do:**
Manually test the complete address management flow and document testing procedures.

**Testing checklist:**

1. **Address List Page**
   - [ ] Page loads without errors
   - [ ] Empty state displays when no addresses
   - [ ] Loading state shows while fetching
   - [ ] Error state displays on API failure
   - [ ] Address cards display all information correctly
   - [ ] Type badges (Shipping/Billing) show correctly
   - [ ] Default badges show for default addresses

2. **Add Address**
   - [ ] "Add Address" button opens dialog
   - [ ] Form displays all required fields
   - [ ] Form validation works (required fields, max lengths, phone regex)
   - [ ] Can select type (shipping/billing)
   - [ ] Can set as default
   - [ ] Submit creates address successfully
   - [ ] Success toast appears
   - [ ] Dialog closes after success
   - [ ] Address list updates with new address
   - [ ] API receives correct data format

3. **Edit Address**
   - [ ] Edit button opens dialog with populated form
   - [ ] All fields pre-filled with current values
   - [ ] Can modify all fields
   - [ ] Can change default status
   - [ ] Submit updates address successfully
   - [ ] Success toast appears
   - [ ] Dialog closes after success
   - [ ] Address card updates immediately
   - [ ] API receives correct data format

4. **Delete Address**
   - [ ] Delete button opens confirmation dialog
   - [ ] Confirmation text is clear
   - [ ] Cancel button closes dialog without deleting
   - [ ] Confirm button deletes address
   - [ ] Success toast appears
   - [ ] Address removed from list immediately
   - [ ] API endpoint called correctly

5. **Default Address Logic**
   - [ ] Setting address as default shows badge
   - [ ] Setting new default unsets previous default (same type)
   - [ ] Can have separate defaults for shipping and billing
   - [ ] Default badge persists after page refresh

6. **Checkout Integration**
   - [ ] Saved shipping addresses display in checkout
   - [ ] Default shipping address auto-selected
   - [ ] Selecting address populates form fields correctly
   - [ ] Can switch to manual entry
   - [ ] Can switch back to saved addresses
   - [ ] "Save to account" checkbox appears (if manual entry)
   - [ ] New address saves to account when checked
   - [ ] Checkout completes successfully with saved address
   - [ ] Checkout completes successfully with manual address

7. **Edge Cases**
   - [ ] No addresses: empty state shows, checkout uses manual entry
   - [ ] Only billing addresses: checkout uses manual entry
   - [ ] Network error: error state shows, retry possible
   - [ ] Validation errors: error messages display inline
   - [ ] Long addresses: UI doesn't break (overflow handling)
   - [ ] Special characters in fields: handled correctly
   - [ ] Multiple rapid clicks: debounced, no duplicate requests

8. **API Integration**
   - [ ] GET /api/customers/me/addresses returns addresses
   - [ ] POST /api/customers/me/addresses creates address
   - [ ] PUT /api/customers/me/addresses/:id updates address
   - [ ] DELETE /api/customers/me/addresses/:id deletes address
   - [ ] React Query cache invalidates after mutations
   - [ ] Loading states accurate
   - [ ] Error handling covers all failure scenarios

9. **Responsive Design**
   - [ ] Desktop: 2-column grid layout
   - [ ] Tablet: 2-column or 1-column based on width
   - [ ] Mobile: 1-column layout
   - [ ] Dialogs fit on small screens
   - [ ] Forms usable on mobile
   - [ ] Touch targets adequate (min 44x44px)

10. **Accessibility**
    - [ ] Form labels associated with inputs
    - [ ] Error messages announced to screen readers
    - [ ] Keyboard navigation works (Tab, Enter, Esc)
    - [ ] Focus management in dialogs
    - [ ] ARIA labels on icon buttons
    - [ ] Color contrast sufficient

**Manual Testing Steps:**

```bash
# 1. Start the development server
cd apps/lab404-website
npm run dev

# 2. Navigate to http://localhost:3000/account/addresses

# 3. Test Add Address
# - Click "Add Address"
# - Fill in all required fields
# - Submit form
# - Verify success toast
# - Verify address appears in list

# 4. Test Edit Address
# - Click edit button on an address
# - Modify some fields
# - Submit form
# - Verify updates reflected

# 5. Test Delete Address
# - Click delete button
# - Confirm deletion
# - Verify address removed

# 6. Test Default Address Toggle
# - Add multiple addresses of same type
# - Set one as default
# - Set another as default
# - Verify only one default per type

# 7. Test Checkout Integration
# - Navigate to /checkout
# - Verify saved addresses appear
# - Select an address
# - Verify form populates
# - Complete checkout
```

**Success criteria:**
- All 10 test categories pass
- No console errors
- API calls succeed
- UI updates correctly
- Toast notifications appear
- Documentation created

---

## Verification

After completing all tasks, verify:

1. **Address List Functionality**
   - [ ] Address list page displays live data from API
   - [ ] Loading, error, and empty states work
   - [ ] Type and default badges display correctly

2. **CRUD Operations**
   - [ ] Can create new addresses
   - [ ] Can edit existing addresses
   - [ ] Can delete addresses
   - [ ] All operations show toast notifications
   - [ ] React Query cache updates correctly

3. **Form Validation**
   - [ ] All required fields validated
   - [ ] Max length constraints enforced
   - [ ] Phone number regex validation works
   - [ ] Error messages display correctly

4. **Default Address Logic**
   - [ ] Can set address as default
   - [ ] Only one default per type (shipping/billing)
   - [ ] Default badge displays on address cards
   - [ ] Default address auto-selected in checkout

5. **Checkout Integration**
   - [ ] Saved addresses display in checkout
   - [ ] Address selection populates form
   - [ ] Can switch between saved and manual entry
   - [ ] "Save to account" checkbox works

6. **Code Quality**
   - [ ] TypeScript types are correct
   - [ ] No TypeScript errors
   - [ ] No console errors or warnings
   - [ ] Components follow existing patterns
   - [ ] Code is clean and well-structured

---

## Success Criteria

- [ ] React Query hooks created for all address operations (useAddresses, useCreateAddress, useUpdateAddress, useDeleteAddress)
- [ ] AddressForm component created with full validation matching API schema
- [ ] Address list page updated with live data and full CRUD functionality
- [ ] Checkout page integrated with saved addresses
- [ ] TypeScript types file created and used consistently
- [ ] All address operations work correctly (create, read, update, delete)
- [ ] Default address logic functions properly (one default per type)
- [ ] Form validation matches API requirements exactly
- [ ] Loading, error, and empty states handled
- [ ] Toast notifications for all operations
- [ ] Dialogs (add/edit/delete) work correctly
- [ ] Responsive design (desktop 2-column, mobile 1-column)
- [ ] Testing documentation created with comprehensive checklist
- [ ] All manual tests pass
- [ ] No console errors or warnings
- [ ] Code follows existing patterns and is type-safe

---

## Output

After completing this plan:

**Files Created (5):**
1. `apps/lab404-website/src/hooks/use-addresses.ts` - React Query hooks for address operations
2. `apps/lab404-website/src/components/addresses/address-form.tsx` - Reusable address form component
3. `apps/lab404-website/src/types/address.ts` - TypeScript types for addresses
4. `.planning/phases/06-customer-account-addresses/06-01-TESTING.md` - Testing documentation

**Files Modified (2):**
1. `apps/lab404-website/src/app/account/addresses/page.tsx` - Address list with live data and CRUD operations
2. `apps/lab404-website/src/app/checkout/page.tsx` - Checkout with saved address selection

**Deliverables:**
- Fully functional address management system
- Integration with checkout flow
- Comprehensive testing documentation
- Type-safe implementation throughout

**Next Steps:**
- Execute testing checklist
- Deploy to staging for QA review
- Plan Phase 7: Customer Account - Profile & Settings
